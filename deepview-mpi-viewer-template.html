<!DOCTYPE html>
<html lang="en">
<head>
    <title>HoloDepth MPI Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: Monospace; font-size: 13px; line-height: 24px; overscroll-behavior: none; }
        a { color: #ff0; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; display:block; }
    </style>
</head>
<body>
    <div id="info">HoloDepth MPI Viewer</div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // <!-- INJECT_MPI_DATA_HERE -->

        let camera, scene, renderer;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        init();
        animate();

        function init() {
            const container = document.getElementById('container');
            const [focal_px, principal_point_x, principal_point_y] = mpi_config.camera_intrinsics;
            const aspect = mpi_config.img_width / mpi_config.img_height;
            const fov = 2 * Math.atan(mpi_config.img_height / (2 * focal_px)) * (180 / Math.PI);
            
            camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
            
            const projMatrix = new THREE.Matrix4();
            const near = camera.near;
            const far = camera.far;
            const top = near * Math.tan(THREE.MathUtils.degToRad(0.5 * fov));
            const height = 2 * top;
            const width = aspect * height;
            const left = -0.5 * width;
            const skew = (principal_point_x - (mpi_config.img_width / 2)) / mpi_config.img_width;
            projMatrix.makePerspective(left + skew * width, left + skew * width + width, top, top - height, near, far);
            camera.projectionMatrix = projMatrix;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x151515);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            const textureLoader = new THREE.TextureLoader();
            const num_planes = mpi_config.image_uris.length;

            for (let i = 0; i < num_planes; i++) {
                const depth = mpi_config.plane_depths[i];
                const texture = textureLoader.load(mpi_config.image_uris[i]);
                
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.NormalBlending, 
                    depthWrite: false
                });

                const planeHeight = (mpi_config.img_height / focal_px) * depth;
                const planeWidth = (mpi_config.img_width / focal_px) * depth;

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const plane = new THREE.Mesh(geometry, material);
                plane.position.z = -depth;
                scene.add(plane);
            }

            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        // ======================================================================
        // --- THE FIX ---
        // This new render function keeps the camera's position stable at (0,0,0)
        // and instead pivots its gaze. This creates a realistic parallax effect
        // instead of the "sliding planes" bug.
        function render() {
            // Target coordinates for the camera to look at.
            // These are based on mouse position but are heavily dampened for a subtle effect.
            const targetX = mouseX * 0.001;
            const targetY = mouseY * 0.001;

            // Smoothly interpolate the camera's rotation to look at the new target.
            // We use a small factor (0.05) to make the movement fluid.
            camera.lookAt(
                camera.position.x + (targetX - camera.position.x) * 0.05,
                camera.position.y + (-targetY - camera.position.y) * 0.05,
                camera.position.z - 1 // Look straight ahead into the scene
            );
            
            renderer.render(scene, camera);
        }
        // ======================================================================
    </script>
</body>
</html>